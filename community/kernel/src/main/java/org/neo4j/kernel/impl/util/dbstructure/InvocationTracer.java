/**
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.kernel.impl.util.dbstructure;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

import org.neo4j.helpers.Pair;
import org.neo4j.helpers.collection.Visitable;
import org.neo4j.kernel.api.constraints.UniquenessConstraint;
import org.neo4j.kernel.api.index.IndexDescriptor;

import static java.lang.String.format;

public class InvocationTracer<C> implements InvocationHandler
{
    private static final String LINE_SEPARATOR = System.getProperty( "line.separator" );

    private final String generatedClassPackage;
    private final String generatedClassName;

    private final StringBuilder builder;
    private final Class<C> interfaceClass;

    public InvocationTracer( String generatedClassNameWithPackage, Class<C> interfaceClass )
    {
        if ( generatedClassNameWithPackage.contains( "%" ) )
        {
            throw new IllegalArgumentException( "Format character in generated class name: " + generatedClassNameWithPackage );
        }

        Pair<String, String> parsedGenerated = parseQualifiedClassName( generatedClassNameWithPackage );
        this.generatedClassPackage = parsedGenerated.first();
        this.generatedClassName = parsedGenerated.other();

        this.interfaceClass = interfaceClass;

        this.builder = new StringBuilder();
    }

    public C newProxy()
    {
        return newProxy( interfaceClass );
    }

    public <P extends C> P newProxy( Class<P> proxyClass )
    {
        ClassLoader classLoader = proxyClass.getClassLoader();
        return proxyClass.cast(
            Proxy.newProxyInstance( classLoader, new Class[] { proxyClass }, this )
        );
    }

    @Override
    public String toString()
    {
        StringBuilder result = new StringBuilder();
        printPreamble( result );
        printTrace( result );
        printAppendix( result );
        return result.toString();
    }

    public String getGeneratedPackageName()
    {
        return generatedClassPackage;
    }

    public String getGeneratedClassName()
    {
        return generatedClassName;
    }

    private void printPreamble( StringBuilder builder )
    {
        String interfaceSimpleName = interfaceClass.getSimpleName();
        String interfaceClassName = interfaceSimpleName.length() == 0 ? interfaceClass.getCanonicalName() : interfaceSimpleName;
        println( builder, "package %s;", generatedClassPackage );
        println( builder );
        println( builder, "import org.neo4j.kernel.api.constraints.UniquenessConstraint;");
        println( builder, "import org.neo4j.kernel.api.index.IndexDescriptor;");
        println( builder, "import org.neo4j.helpers.collection.Visitable;");
        println( builder );
        println( builder, "//" );
        println( builder, "// GENERATED FILE. DO NOT EDIT. " );
        println( builder, "//" );
        println( builder, "// This has been generated by %s", getClass().getCanonicalName() );
        println( builder, "//" );
        println( builder );
        println( builder, "public enum %s implements %s<%s>", generatedClassName, Visitable.class.getSimpleName(), interfaceClassName );
        println( builder, "{" );
        println( builder, "    INSTANCE;" );
        println( builder );
        println( builder, "    public void accept( %s visitor )", interfaceClassName );
        println( builder, "    {" );
    }

    private void printTrace( StringBuilder result )
    {
        result.append( builder );
    }

    @Override
    public Object invoke( Object proxy, Method method, Object[] args ) throws Throwable
    {
        if ( method.getReturnType().equals( Void.TYPE ) )
        {
            // println invocation start
            print( builder, "        visitor.%s(", method.getName() );

            // println arguments
            for ( int i = 0; i < args.length; i++ )
            {
                Object arg = args[i];

                if ( i > 0 )
                {
                    print( builder, ", " );
                }
                else
                {
                    print( builder, " " );
                }

                printArgument( arg );
            }

            // println invocation end
            if ( args.length == 0 )
            {
                println( builder, ");" );
            }
            else
            {
                println( builder, " );" );
            }

            return null;
        }
        else
        {
            throw new IllegalArgumentException( "InvocationTraceGenerator only works with void methods" );
        }
    }

    private void printArgument( Object arg )
    {
        if ( arg instanceof String )
        {
            builder.append( '"' );
            escape( builder, arg.toString() );
            builder.append( '"' );
        }
        else if ( arg instanceof Long )
        {
            builder.append( arg.toString() );
            builder.append( 'l' );
        }
        else if ( arg instanceof Integer )
        {
            builder.append( arg.toString() );
        }
        else if ( arg instanceof Double )
        {
            builder.append( arg.toString() );
            builder.append('d' );
        }
        else if ( arg instanceof IndexDescriptor )
        {
            IndexDescriptor descriptor = (IndexDescriptor) arg;
            builder.append( format( "new IndexDescriptor( %s, %s )", descriptor.getLabelId(), descriptor
                    .getPropertyKeyId() ) );
        }
        else if ( arg instanceof UniquenessConstraint )
        {
            UniquenessConstraint constraint = (UniquenessConstraint) arg;
            builder.append( format( "new UniquenessConstraint( %s, %s )", constraint.label(), constraint.propertyKeyId() ) );
        }
        else
        {
            throw new IllegalArgumentException( format(
                    "Can't handle argument of type: %s with value: %s", arg.getClass(), arg
            ) );
        }
    }

    private void escape( StringBuilder builder, String arg )
    {
        int len = arg.length();
        for ( int i = 0; i < len; i++ )
        {
            char ch = arg.charAt( i );
            switch (ch) {
                case '"':
                    builder.append( "\\\"");
                    break;

                case '\'':
                    builder.append( "\\\'");
                    break;

                case '\\':
                    builder.append( "\\\\");
                    break;

                case '\n':
                    builder.append( "\\n");

                case '\t':
                    builder.append( "\\t");

                case '\r':
                    builder.append( "\\r");

                case '\b':
                    builder.append( "\\b");

                case '\f':
                    builder.append( "\\f");

                default:
                    builder.append( ch );
                    break;
            }
        }
    }

    private static void printAppendix( StringBuilder builder )
    {
        println( builder, "   }" );
        println( builder, "}" );
        println( builder );
        println( builder, "/* END OF GENERATED CONTENT */" );
    }

    private static void println( StringBuilder builder, String format, Object... args )
    {
        print( builder, format, args );
        println( builder );
    }

    private static void print( StringBuilder builder, String format, Object... args )
    {
        builder.append( format( format, args ) );
    }

    private static void println( StringBuilder builder )
    {
        builder.append( LINE_SEPARATOR );
    }

    private static Pair<String, String> parseQualifiedClassName( String className )
    {
        int index = className.lastIndexOf( "." );

        if ( index < 0 )
        {
            throw new IllegalArgumentException( "Expected fully qualified class name but got: " + className );
        }

        return Pair.of( className.substring( 0, index ), className.substring( index + 1 ) );
    }
}
